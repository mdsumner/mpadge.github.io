{{> header}}
{{> blog_entry_header}}

<div class="cell medium-2 large-2 left">
<nav class="sticky-container" data-sticky-container>
<div class="sticky" data-sticky data-anchor="how-i-make-this-site" data-sticky-on="large" data-margin-top="5">
<ul class="vertical menu" data-magellan>
<li><a href="#C-templates-and-Rcpp" style="color:#111111">C++ templates and Rcpp</a></li>
<li><a href="#A-better-level-of-abstraction" style="color:#111111">A better level of abstraction</a></li>
<li><a href="#The-final-code" style="color:#111111">The final code</a></li>
</div>
</nav>
</div>

<div class="cell medium-10 large-10">
<div class="sections">
{{#markdown}}
<section id="C-templates-and-Rcpp" data-magellan-target="C-templates-and-Rcpp"><h1>C++ templates and Rcpp</h></section>

C++ templates are really useful. Templates allow you to code a function
able to accept arguments of different types that can’t necessarily be
known until compile time. There is, however, no such thing as an Rcpp
template – all inputs and outputs must have defined types. This blog
entry is about how to maximise the usefulness of C++ templates in an
Rcpp context.

It’s not a difficult process, and as often in programming, it’s about
finding the most efficient level of abstraction. Templates are one of
the coolest ways to “abstract” C++ code – generally meaning abstracting
away from specific variable (class, structure, whatever …) types to
generic templated forms that accept multiple, or indeed any possible,
types. Templates in
<a target="_blank" rel="noopener noreferrer" href="https://rust-lang.org">
rust </a> just work - types are directly inferred, and any potential
conflicts will be caught at compile time.
<a target="_blank" rel="noopener noreferrer" href="https://rust-lang.org">
rust </a> is the gold standard in which template abstraction is as
pain-free as possible. C++ templates are, in contrast, somewhat more
painful, as a minimal generic template must be explicitly specified.
This is often as simple as replacing some function definition, say:

``` c++
int my_function (int my_integer_input)
{
    int result = my_integer_input;
    // do something with `result`
    return result;
}
```

with a templated version:

``` c++
template <class T>
T my_function_t (T my_generic_input)
{
    T result = my_generic_input;
    // do something with `result`
    return result;
}
```

As it stands, `my_function_t` will accept inputs of any arbitrary kinds.
(There are also ways to permit templated code to only accept objects of
some pre-defined classes.) An Rcpp version of the first function might
look like this:

``` c++
// [[Rcpp::export]]
int my_rcpp_function (int my_integer_input)
{
    int result = my_integer_input;
    // do something with `result`
    return result;
}
```

The problem arises when you try to do something like this:

``` c++
// [[Rcpp::export]]
template <class T>
int rcpp_template (T input)
{
    int result = Rcpp::as <int> (input);
    // do something with `result`
    return result;
}
```

and that takes you here:

``` c++
RcppExports.cpp:46:36: error: use of undeclared identifier 'T'
    Rcpp::traits::input_parameter< T >::type input(inputSEXP);
                                                              ^
RcppExports.cpp:46:41: error: no type named 'type' in the global namespace
    Rcpp::traits::input_parameter< T >::type input(inputSEXP);
                                                                    ~~^
2 errors generated.
```

This provides highly informative error messages that clearly indicate
that the cause is the ability to infer appropriate `inputSEXP` types
(itself a necessity of **R** being written in C, not C++, and so knowing
nothing about inferred types or templates). What we can nevertheless do
here is replace our undefined type, `T`, with an equivalently undefined
and generic `SEXP` (and let’s define our function while we’re at it to
square the input; and also, if you’re wondering what all this `SEXP`
stuff is, you could take a wee digression over to
<a target="_blank" rel="noopener noreferrer" href="https://bragqut.github.io/2016/05/26/milesmcbain-rnoprimitives/">
Miles McBain’s brief but illuminating ramblings on the topic </a>)

``` c++
// [[Rcpp::export]]
int rcpp_template (SEXP input)
{
    int result = Rcpp::as <int> (input);
    return result * result;
}
```

This can be then called from **R**, and will return an integer output.
(The `Rcpp::as <int> ()` is a wrapper for `static_cast <int> ()`, which
simply truncates decimals, so `rcpp_template(1.9)` will give 1.) What
about generic return values? The next obvious step would be to try this:

``` c++
// [[Rcpp::export]]
SEXP rcpp_template2 (SEXP input)
{
    return input * input;
}
```

This would obviously be rather dangerous if it actually worked, but we
don’t need to worry because it fails with this:

``` c++
error: invalid operands to binary expression ('SEXP' (aka 'SEXPREC *') and 'SEXP')
SEXP result = input * input;
                        ~~~~~ ^ ~~~~~
1 error generated.
```

The arrow points to the “operand”, indicating that this has defaulted to
an attempt to implement bit-wise multiplication of two generic pointer
objects (an `SEXP` object is nothing but a pointer to the underlying
structure it points to, an `SEXPREC` object). So that all leaves us now
knowing that the most we can do is to send generic inputs from **R** to
C++ functions as `SEXP` parameters, and then coerce them with the magic
of `Rcpp::as()`. This is of course also potentially dangerous:

``` r
rcpp_template (2.9) # = 4; okay
rcpp_template ("2.9")
# Error in rcpp_template(input) :
#   Not compatible with requested type: [type=character; target=integer].
```

<br>

<section id="A-better-level-of-abstraction" data-magellan-target="A-better-level-of-abstraction"><h2>A better level of abstraction</h></section>

The key to using C++ templates in R is the realisation that (i)
<a target="_blank" rel="noopener noreferrer" href="http://adv-r.had.co.nz/C-interface.html">
R’s C interface </a> only knows about `SEXP`, itself a template for a
generic “S-EXPression”; and (ii) All `SEXP` objects are mere pointers to
C arrays, which is why R neither can nor does make any distinction
between single values and vectors – all R objects are vectors at heart.
This suggests something like the following code—which does not work:

``` c++
#include <Rcpp.h>

template <class T>
T mysquare (T &x)
{
    for (size_t i = 0; i < x.size (); i++)
        x (i) = x (i) * x (i);
    return x;
}

// [[Rcpp::export]]
SEXP rcpp_mysquare (SEXP &x)
{
    return mysquare (x);
}
```

That code will fail to compile because of “incomplete definition of type
‘SEXPREC’” (where a `SEXPREC` is a structure pointed to by an `SEXP`)—in
other words, R has no way of inferring the type of data pointed to by
the `SEXP`. The trick is to have an additional “type-selector” function
that recognises and typecasts the input type as one of the
<a target="_blank" rel="noopener noreferrer" href="https://cran.r-project.org/doc/manuals/R-exts.html#Registering-native-routines">
six possible R types </a>. We’re only interested in a couple of those
here, representing the integer and real or floating-point types, which
are respectively `INTSXP` and `REALSXP`. Recalling that there is no
distinction between a single integer or numeric (floating-point) value
and equivalent vectors of these, we can distinguish these two cases
through casting via `Rcpp::as` to `Rcpp` equivalents of either integer
or numeric vectors with the following additional code, representing our
“type selector” function:

``` c++
SEXP mysquare (SEXP &x)
{
    switch (TYPEOF (x))
    {
        case INTSXP: {
                         Rcpp::IntegerVector iv = Rcpp::as <Rcpp::IntegerVector> (x);
                         return mysquare (iv);
                     }
        case REALSXP: {
                         Rcpp::NumericVector nv = Rcpp::as <Rcpp::NumericVector> (x);
                         return mysquare (nv);
                     }
        default: { Rcpp::stop ("incompatible type");    }
    }
    return x; // this should never happen
}
```

This function takes a generic (`SEXP`) input and returns a generic
output, yet deploys actual calls to the templated version of `mysquare`
with specified (`Rcpp`) types, ensuring that the above templated
function will always be able to infer the input type. The `default`
`Rcpp::stop` ensures that types other than our desired two are not
processed further, preventing for example attempts to calculate the
square of `"a"`. Inserting this “type-selector” code in the above code
(and presuming all to be in a file `src.cpp`) permits a generic
`SEXP`-in / `SEXP`-out function (our `rcpp_mysquare` in the above code)
to be deployed to specific types, and then simply passed to a generic
C++ template function. The whole thing then works like this:

``` r
Rcpp::sourceCpp ("src.cpp") # source the file, placing the Rcpp::export-ed function in workspace
x <- 1:5
x <- rcpp_mysquare (x)
x
```

    ## [1]  1  4  9 16 25

``` r
class (x)
```

    ## [1] "integer"

``` r
storage.mode (x) <- "numeric"
x <- rcpp_mysquare (x)
x
```

    ## [1]   1  16  81 256 625

``` r
class (x)
```

    ## [1] "numeric"

An integer vector gives integer return values, and a numeric
(floating-point) vector gives numeric return values. There you have it:
templating through the magic of `SEXP`. Gratitude extended to Dirk
Eddelbeuttel and David Cooley for advice and helpful pointers.

<section id="The-final-code" data-magellan-target="The-final-code"><h2>The final code</h></section>

Just to make it clear, here’s the above code all placed in a single
place:

``` c++
#include <Rcpp.h>

template <class T>
inline T mysquare (T &x)
{
    for (size_t i = 0; i < x.size (); i++)
        x (i) = x (i) * x (i);
    return x;
}

inline SEXP mysquare (SEXP &x)
{
    switch (TYPEOF (x))
    {
        case INTSXP: {
                         Rcpp::IntegerVector iv = Rcpp::as <Rcpp::IntegerVector> (x);
                         return mysquare (iv);
                     }
        case REALSXP: {
                         Rcpp::NumericVector nv = Rcpp::as <Rcpp::NumericVector> (x);
                         return mysquare (nv);
                     }
        default: { Rcpp::stop ("error");    }
    }
    return x; // this never happens
}

// [[Rcpp::export]]
SEXP rcpp_mysquare (SEXP &x)
{
    return mysquare (x);
}
```
<div style="text-align: right">
Originally posted: 07 May 19
Updated: 16 Jul 19
</div>
{{/markdown}}
</div>
</div>
{{> blog_entry_footer}}
{{> footer}}
